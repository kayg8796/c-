#include <iostream>
using std::string; // this is so that you don't have to put std everytime you are using string.


/*
OOP
a class is the building block of oop. A class is basically a user-defined datatype.
predefined data types include int, float etc
A class has attributes/variables and behaviours/methods

    Access modifiers
    
    Private:
    The private members can only be accessed from within the class.
    However, friend classes and friend functions can access private members.

    Protected:
    The protected members can be accessed within the class and from the child classes

    Public:
    The public members are accessible from any part of the program.



    OOP Concepts

    Encapsulation:
    This is the idea of tying data to methods that exist within a class.
    We do this to prevent external users/classes from directly manipulating the attributes of a class.
    Typically these attributes are set as private alongside public methods (usually getters and setters) to give external methods access to such data.

    Abstraction :
    Hiding a complex thing behind a procedure that appears simple
    This is done using abstract classes
    consider the abstract class as a contract with terms, any class that signs
    this contract must provide implementations for the methods within
    the methods are made mandatory be making the methods virtual
    The simplicity is seen in the abstract class while the complexity is left for the classes that sign the contract to implement.

    Inheritance:
    This aspect is quite intuitive and operates just as the name suggest
    A child inherits all the attributes and methods of the parent class and adds  to its own.
    Note however that , a child object can only access "protected" data and not "private" data.

    Polymorphism
    The ability of an object or a method to have many forms. 
    The most common use of polymorphism is when a parent class reference is used to refer to a child oclass object 
    as demonstrated with e1 is function main below.

 */

class Employee :AbstractEmployee{   
    /*I sign the abstract employee class therefore I provide 
    //implementation for the askforpromotion method in it */


    /*where constructors are not defined , a default constructor is generated by your compiler.
    a constructor does not have a return type, has the same name as the class and is generally public (there are exceptions) */




protected:            //everything beneath this access modifier is protected. Note that 'private' is the default access modifier.
    string Name;
    string Company;
    int Age;


public:
    void setName(string name){
        Name = name;
    }
    string getName(){
        return Name;
    }


    string getCompany()         // Getters and setters to demonstrate encapsulation
    {
        return Company;
    }
    void setCompany(string company)
    {
        Company = company;
    }


    void setAge(int age){
        if (age>=18)                      //we see here that encapsulation gives us the power to apply rules to how private data should be handled
        {
            Age = age;
        } else{
            std::cout<< "Age should be greater that 18 " << std::endl;
        }
        
    }
    int getAge(){
        return Age;
    }

    void IntroduceYourself(){              // implementation of method in abstract class
    std::cout<< "Name - " << Name << std::endl;
    std::cout<< "Company : " << Company << std::endl;
    }
    Employee(string name, string company, int age){
    }

    void AskForPromotion(){
        if (Age>30)
        {
            std::cout << "Promoted" << Name << std::endl;
        }else{
            std::cout << "No promotion" << std::endl;
        }
        
    }

    virtual void work {
        std::cout<< Name << "is preparing backlogs" << std:endl;
    
    // the significance of virtual here is to say , please check if there
    // are implementations of this method in child classes and execute them instead.
    }

};

class AbstractEmployee //abstraction demonstrated
{
    virtual void AskForpromotion()=0;
};


class Developer: public Employee{ //since a constructor for the parent class was defined, same has to be done for the child
// the public access modifier before employee above allows developer objects
// to access protected attributes and methods of employee.

    public:
        string favlanguage;
        Developer(string name, string company, int age, string language)
            :Employee(name,company,age) //initializing the parent constructor
            {
                favlanguage = language;

        }

        void work {                           //alternate implementation of work function to demonstrate polymorphism
        std::cout<< Name << "is writing code" << std:endl;
    }
}








int main (){

    Employee employee1 = Employee("George John","Axel",25);
    employee1.setAge(50);
    employee1.setCompany("Google");
    employee1.setName("John");
    employee1.IntroduceYourself();

    Developer d = Developer("johan","comp",34,"c++");
    Employee* e1 = &d;
    Employee* e2 = &employee1;

    // an employee pointer can be used for referencing a developer
    //object because a developer is intrisically an employee

    e1->work(); // -> is used by pointers to access object attributes and methods
    e2->work();

    // polymorphism is demonstrated above. the work method performs different operations for e1 and e2.


}